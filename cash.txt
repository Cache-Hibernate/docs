Кеширование в Hibernate:
========================

> Hibernate обращается к кэшу в следующих случаях:
  Приложение выполняет поиск сущности по идентификатору
  Приложение выполняет ленивую загрузку коллекции

> Кэши разделяются в зависимости от области видимости (scope) на следующие виды:
  "Session scope cache"     - Кэш привязанный к транзакции, действительный только пока транзакция не завершиться. Каждая транзакция имеет свой кэш, следовательно, доступ к данному кэшу не может быть осуществлён в несколько потоков.
  "Process scope cache"     - Кэш привязанный к определённому процессу конкретной JVM и общий для многих транзакций с возможностью параллельного доступа.
  "Cluster scope cache"     - Кэш общий для нескольких процессов на одной машине или нескольких машин в составе кластера.
  "Transaction scope cache" - представляет собой кэш первого уровня hibernate, кэш же второго уровня может быть реализован либо в области видимости процесса илибо как распределённый кэш.

> Кэш первого уровня в hibernate связан с объектом сессии, он включён по умолчанию и нет возможности отключить его.
  Когда вы передаёте объект в метод ((save(),update(),saveOrUpdate())) или пытаетесь обратиться к нему с помощью методов ((load(),get(),scroll(),list(),iterate())) - выполняется добавление элемента в кэш сессии. И следующий раз, когда нужно будет произвести повторную выборку данного объекта из БД в текущей сессии обращения к БД уже не произойдёт, объект будет взят из кэша.
> Обнуление кэша происходит после закрытия сессии. Так же, содержимым кэша можно управлять используя методы класса Session:
  contains() - проверяет сохранён ли объект в кэше
  flush()    - синхронизирует содержимое кэша с базой данных
  evict()    - удаляет объект из кэша
  clear()    - обнуляет кэш

> Кэш второго уровня в hibernate может быть настроен как 'кэш процесса' и 'распеределённый кэш' (в рамках JVM или кластера).
  В отличие от кэша первого уровня, использование кэша второго уровня является опциональным, (он может быть как включён так и отключён).
> В кэше второго уровня сущности хранятся в разобранном состоянии (что-то наподобие сериализованного состояния, однако, используемый алгоритм намного быстрее сериализации). Соответственно, доступ к объектам, сохранённым в кэше второго уроня осуществляется по значению. Доступ к сущности может осуществляться из параллельных транзакций (каждая транзакция будет иметь свою копию данных).
> Сам Hibernate не реализует кеширование как таковое, лишь предоставляет структуру для его реализации.
  Поэтому подключить можно любую из популярных реализаций которая соответствует спецификации ORM фреймворка ("EHCache","OSCache","SwarmCache","JBoss TreeCache")
>> "EhCache"              - изначально разрабатывался как кэш уровня процесса, однако, в последник версиях появилась возможность реализации так же распределённого кэша. Имеется поддрержка кэша запросов и выгрузки данных на диск.
>> "OpenSymphony OSCache" - реализует кэш только на уровне процесса. Поддерживает кэш запросов и выгрузку данных на диск.
>> "SwarmCache"           - распределённый кэш, который базирется на JGroups. Нет поддержки кэша запросов.
>> "JBoss Cache"          - может быть как локальным так и распределённым. Это полностью транзакционный кэш с возможностью репликации и инвалидаци, а так же с возможностью обмена как синхронными так и асинхронными валидационными сообщениями.
  Для включения необходимо добавить следующие строки в Вашем конфигурационном файле JPA (persistence.xml):
> Стратегии паралельного доступа к кэшу второго уровня:
  "read only"            - используется для данных, которые часто читаются но никогда не изменяются (изменение данных при использовании этой стратегии приведёт к исключению).
                           Испльзование данного подхода в распределённом кэше позволяет не волноваться об синхронизации данных, однако может привести к сильной загрузке базы на начальном этапе работы кластера пока не закэширует все необходимые объекты.
  "nonstrict read write" - используется для данных, которые изменяются очень редко (при параллельном доступе к данным из разных транзакций данная стратегия не даёт никакой гарантии, что в кэше будут сохранены актуальные данные, так как Hibernate никак не изолирует от других транзакций данные во время изменения).
                           Не слудует использовать данную стратегию, если небольшая вероятность считывания устаревших данных критична для приложения.
  "read write"           - используется для данных которые гораздо чаще читаются, чем обновляются, однако, устаревание которых критично для приложения. (при этом подходе, данные блокируются для чтения во время их изменении с использованием “soft-lock” механизма).
                           Недостатки - так если в кластере имеется возможность изменения одних и тех же данных разными узлами, довольно часто могут случаться блокировки устаревших данных в кэше, что сводит на нет приемущества использования данной стратегии.
                           Данная стратегия обеспечивает уровень изоляции транзакций "read commited"
  "transactional"        - используется, когда необходима изоляция транзакций вполоть до уровня "repeatable read". Так же как и предыдущие используется для данных, которые гораздо чаще читаются нежели обновляются.
>> hibernate.connection.isolation = 4
1. SERIALIZABLE
   На данном уровне MySQL блокирует каждую строку над которой происходит какое либо действие, это исключает появление проблемы «фантомов». На самом деле смысла использовать этот уровень нет, т.к. InnoDB и менее популярный Falcon решают эту проблему.
2. REPEATABLE READ
   Этот уровень используется по умолчанию в MySQL. Отличается от второго тем, что вновь добавленные данные уже будут доступны внутри транзакции, но не будут доступны до подтверждения извне.
   Здесь может возникнуть теоретическая проблема «фантомного чтения». Когда внутри одной транзакции происходит чтение данных, другая транзакция в этот момент вставляет новые данные, а первая транзакция снова читает те-же самые данные.
3. READ COMMTITED
   В данном случае прочитать данные возможно только после вызова COMMIT. При чем внутри транзакции данные тоже будут еще не доступны.
   Если рассмотреть транзакцию выше, то первый SELECT ничего не вернет, т.к. таблица у нас еще пустая и транзакция не подтверждена.
4. READ UNCOMMITTED
   Рассмотрим транзакцию выше. После INSERT данные сразу-же станут доступны для чтения. Тоесть еще до вызова COMMIT вне транзакции можно получить только что добавленные данные. В английской литературе это называется dirty read («грязное чтение»). Этот уровень редко используется на практике, да вообще редко кто меняет эти самые уровни.

> (Кеш запросов похож на кеш второго уровня) но в отличии от него ключом к данным кеша выступает не идентификатор объекта, а совокупность параметров запроса (таким образом, этот кеш рационально использовать с кешем второго уровня).
  Это как раз то место, где можно использовать кеш запросов:
> Кеш запросов - самый не эффективный из всех перечисленных этому есть несколько причин:
  1. ключом к данным этого кеша выступает не только параметры запроса, но и сам запрос (это особенно важно, когда запросов много и они большие)
  2. Кеш запросов очень часто сбрасывается (если хоть одна из таблиц которые участвуют в запросе была модифицирована, то кеш будет сброшен и запрос выполнен по новой)

> Регион или область — это логический разделитель памяти вашего кеша.
  Для каждого региона можна настроить свою политику кеширования (если регион не указан то используется регион по умолчанию который имеет полное имя класса для которого применяется кеширование).

> Criteria API позволяет формировать запросы к базе данных программным средствами.



Кеширование в Connection#PreparedStatement:
===========================================
> При следующем выполнении connection.prepareStatement() снова произойдет сначала вызов prepare к БД, затем собственно вызов для выполнения конкретного запроса.
  Во-первых, это два вызова по сети, что не хорошо с точки зрения производительности. Во-вторых, хоть СУБД и закешировало запрос и не будет его второй раз разбирать, у нас уже есть ID запроса после первого раза, зачем нам снова лазить в БД за ним, если его можно где-то сохранить и переиспользовать?
  Собственно так это и реализовано в большинстве драйверов:
1. Connection#prepareStatement(String sql) – здесь и происходит вся магия, по переданной в метод строке драйвер проверяет объект в своем внутреннем (не СУБД!) кеше, и, если тот там есть, возвращает его; если нет – создает новый.** Это называется неявным кешированием (implicit cache)***.
2. Идем дальше: PreparedStatement#close() - собственно этот метод и не оправдывает своего имени в данном случае – он не закрывает на самом деле statement, а помещает его как раз таки в кеш. Физически PreparedStatement закрывается только в случае:
   а) если соединение с БД было закрыто
   б) когда кеш достигает своего максимальной вместимости и нужно освобождать его от старых и малоиспользуемых statement’ов
   в) если кеш отключен
   г) если кеш не поддерживается драйвером
3. PreparedStatements привязаны к одному соединению и не могут быть переиспользованы, то пулы позволяют каждому соединению использовать подготовленные запросы других соединений, что означает, что производительность вырастет еще больше.

> Database Connection Pool - "Apache Tomcat" (...) предоставляет собственное решение:
1. нужно объявить новый ресурс в контексте приложения <Resource name="jdbc/appname" auth="Container"
                                                                type="javax.sql.DataSource" maxActive="100"
                                                                maxIdle="30" maxWait="10000"
                                                                username="username"
                                                                password="password"
                                                                driverClassName="jdbc.driver.name"
                                                                url="jdbc:protocol://hostname:port/dbname"/>
2. Контекст приложения описывается XML-файлом "META-INF/context.xml" <resource-ref>
                                                                        DB Connection
                                                                        <res-ref-name>jdbc/appname</res-ref-name>
                                                                        <res-type>javax.sql.DataSource</res-type>
                                                                        <res-auth>Container</res-auth>
                                                                     </resource-ref>
3. Теперь мы можем использовать этот ресурс в нашем приложении InitialContext initContext= new InitialContext();
                                                               DataSource ds = (DataSource) initContext.lookup("java:comp/env/jdbc/dbconnect");
                                                               Connection conn = ds.getConnection();




Кеширование в Spring Framework 3.1:
===================================
> "общий абстрактный кэш" для прозрачного применения кэширования в приложениях-Spring
  это можно будет сделать с помощью аннотации @Cacheable
> Настроить кеширование в приложении, это делается в xml-файле конфигурации application context-а и настроить cache-manager, например простейший (использующий ConcurrentMap) <bean class="org.springframework.cache.concurrent.ConcurrentCacheFactoryBean" p:name="default"/>
                                                                                                                                                                              <bean class="org.springframework.cache.concurrent.ConcurrentCacheFactoryBean" p:name="books"/>
                                                                                                                                                                              либо ehcache (можно использовать и другие реализации):
  либо ehcache (можно использовать и другие реализации): <bean id="cacheManager" class="org.springframework.cache.ehcache.EhcacheCacheManager" p:cache-manager="ehcache"/>
                                                         <bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" p:config-location="ehcache.xml"/>
> Очистка кеша - @CacheEvict(value = "books", allEntries=true)
