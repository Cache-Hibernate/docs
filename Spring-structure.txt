2. Создание структуры пакетов "Spring WebMVC":
==============================================
> net.schastny.contactmanager.dao 	Слой доступа к данным.
                                    В нём будем размещать Data Access Objects – объекты доступа к данным.
> net.schastny.contactmanager.domain 	Доменный слой.
                                        Именно здесь лежат POJO-классы, описывающие объекты-сущности системы. В нашем случае это класс Contact.
> net.schastny.contactmanager.service 	Сервис-слой приложения.
                                        Содержит интерфейсы, в которых описан функционал приложения. Также содержит одну или несколько практических реализаций этих интерфейсов.
> net.schastny.contactmanager.web 	Веб-слой приложения.
                                    Здесь лежат классы-контроллеры, описывающие порядок взаимодействия пользователя с системой через веб.



Распространенный подход к написанию веб-приложений на Spring WebMVC подразумевает, что у вас есть объекты @Repository (они же DAO), отвечающие за атомарные операции с БД, объекты @Service, инкапсулирующие транзакции, и объекты @Controller, обрабатывающие запросы. Разделение труда довольно удобное, но! Допустим, у вас есть древний проект с какой-нибудь дикой схемой БД или noSQL хранилищем, который вы потихоньку переписываете. Последняя Java, красивая архитектура и... требование поддержки старого хранилища на первом этапе. Решение кажется очевидным: сначала пишем слой Repository для этого хранилища, потом меняем его на реализацию с JPA. И тут находится запрос данных с N параметрами, где N существенно больше единицы, некоторые из параметров могут быть опущены, некоторые могут иметь несколько значений, в общем — надо что-то вроде Criteria API. Параметры приходят от пользователей, вытаскиваются из сессии и конфигурации — тот ещё зоопарк. Что делать?
А. Передавать Map<String,String[]>, вобравший в себя весь зоопарк параметров, из контроллера через сервис напрямую в DAO без разбора и обработки.
Б. Если возможно, делать запрос by example: создавать в контроллере примеры на основе запроса, делать все проверки в сервисе и строить storage-specific запрос в Repository
В. Изобрести велосипед и написать свое Criteria API, транслирующее запросы как в API из JPA, так и в формат запросов старого хранилища.
Г. Гибрид Б и В: вместо общего Criteria API пишем пачку domain-specific DTO
Д. Что-то ещё, о чем я не подумал.